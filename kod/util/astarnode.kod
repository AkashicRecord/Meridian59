AstarNode

constants:
	include blakston.khd
resources:

classvars:

properties:

poParentNode = $

%In order to calculate G, we need to take the G of its parent (the square where we came from) and to add 1 to it. Therefore, the G of each square will represent the total cost of the generated path from point A until the square.
piMovementCost = 0

%To put it simply, we will use the “Manhattan distance method” (Also called “Manhattan length” or “city block distance”) that just counts the number of horizontal and vertical square remaining to reach point B without taking into account of any obstacles or differences of land.
piHeuristicCost = 0

%MovementCost + HeuristicCost
piScore = 0

piRow = 0
piCol = 0

messages:

Constructor(iRow = 0, iCol = 0, oParent = $, iEndRow = 0, iEndCol = 0, diagonal = FALSE)
{
	piRow = iRow;
	piCol = iCol;
	poParentNode = oParent;
	Send(self,@CalculateMovementCost,#diagonal=diagonal);
	Send(self,@CaclculateHeuresticCost,#iEndRow=iEndRow,#iEndCol=iEndCol);
	Send(Self,@CalculateScore);
	return;
}

GetRow()
{
	return piRow;
}

GetCol()
{
	return piCol;
}

GetMovementCost()
{
	return piMovementCost;
}

GetScore()
{
	return piScore;
}

%"G"
CalculateMovementCost(diagonal = FALSE)
{
	%If we have a parent, get its MovementCost (G)
	if poParentNode <> $
	{
		if diagonal
		{
			piMovementCost = Send(poParentNode,@GetMovementCost) + 14;
		}
		else
		{
			piMovementCost = Send(poParentNode,@GetMovementCost) + 10;
		}
		return;
	}
	piMovementCost = 0;
	return piMovementCost;
}

TryNewParent(oNode = $, diagonal = FALSE)
{
	local iNewMovementCost;
	if oNode <> $
	{
		if diagonal
		{
			iNewMovementCost = Send(oNode,@GetMovementCost) + 14;
		}
		else
		{
			iNewMovementCost = Send(oNode,@GetMovementCost) + 10;
		}
		
		if iNewMovementCost < piMovementCost
		{
			poParentNode = oNode;
			piMovementCost = iNewMovementCost;
			Send(self,@CalculateScore);
		}
	}
	return piMovementCost;
}

CaclculateHeuresticCost(iEndRow = 0, iEndCol = 0)
{
	piHeuristicCost = abs(iEndRow - piRow) * 10 + abs(iEndCol - piCol) * 10;
	return piHeuristicCost;
}

CalculateScore()
{
	piScore = piMovementCost + piHeuristicCost;
	return piScore;
}

Recreate()
{
	return;
}

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
